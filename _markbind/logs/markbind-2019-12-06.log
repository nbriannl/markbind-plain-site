2019-12-06T05:49:00.802Z - info: Initialization success.
2019-12-06T05:49:14.672Z - info: Website generation started at 1:49:14 PM
2019-12-06T05:49:14.713Z - info: Building assets...
2019-12-06T05:49:14.724Z - info: Assets built
2019-12-06T05:49:14.725Z - info: Generating pages...
2019-12-06T05:49:15.239Z - info: Pages built
2019-12-06T05:49:15.351Z - info: Website generation complete! Total build time: 0.684s
2019-12-06T05:49:15.423Z - info: Serving "C:\Users\neilb\Projects\markbind-plain-site\_site" at http://127.0.0.1:8080
2019-12-06T05:49:15.424Z - info: Press CTRL+C to stop ...
2019-12-06T05:49:15.453Z - info: Site data built
2019-12-06T05:50:20.369Z - info: Website generation started at 1:50:20 PM
2019-12-06T05:50:20.412Z - info: Building assets...
2019-12-06T05:50:20.426Z - info: Assets built
2019-12-06T05:50:20.428Z - info: Generating pages...
2019-12-06T05:50:20.994Z - info: Pages built
2019-12-06T05:50:21.122Z - info: Website generation complete! Total build time: 0.794s
2019-12-06T05:50:21.123Z - info: Build success!
2019-12-06T05:50:21.137Z - info: Site data built
2019-12-06T05:50:52.919Z - error: Cloning into '..\..\AppData\Roaming\npm\node_modules\markbind-cli\node_modules\gh-pages\.cache\git@github.com!nbriannl!markbind-plain-site.git'...
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.

2019-12-06T05:53:41.652Z - error: fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.

2019-12-06T05:53:55.011Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T05:56:43.548Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T05:58:44.897Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:01:49.773Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:05:11.358Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:07:20.025Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:09:29.049Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:10:49.887Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:12:09.122Z - error: git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.

2019-12-06T06:12:25.946Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:14:45.637Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:16:18.144Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T06:20:08.977Z - info: Website generation started at 2:20:08 PM
2019-12-06T06:20:09.028Z - info: Building assets...
2019-12-06T06:20:09.056Z - info: Assets built
2019-12-06T06:20:09.056Z - info: Generating pages...
2019-12-06T06:20:09.546Z - info: Pages built
2019-12-06T06:20:09.662Z - info: Website generation complete! Total build time: 0.729s
2019-12-06T06:20:09.738Z - info: Serving "C:\Users\neilb\Projects\markbind-plain-site\_site" at http://127.0.0.1:8080
2019-12-06T06:20:09.738Z - info: Press CTRL+C to stop ...
2019-12-06T06:20:09.768Z - info: Site data built
2019-12-06T06:20:30.094Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T07:40:03.133Z - error: Received disconnect from 52.74.223.119 port 22:11: Bye Bye
Disconnected from 52.74.223.119 port 22
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.

2019-12-06T07:40:16.523Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T08:12:19.043Z - error: fatal: A branch named 'gh-pages' already exists.

2019-12-06T08:17:16.280Z - info: Deployed!
2019-12-06T08:27:04.076Z - info: Deployed!
2019-12-06T08:27:59.628Z - info: Deployed!
2019-12-06T08:40:27.459Z - info: Deployed!
2019-12-06T08:40:46.172Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:40:53.057Z - info: Deployed!
2019-12-06T08:41:11.021Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:41:11.023Z - info:  commands=[], options=[flags=-t, --travis [tokenVar], required=0, optional=-14, bool=true, short=-t, long=--travis, description=deploy the site in Travis [GITHUB_TOKEN], flags=-s, --site-config <file>, required=-19, optional=0, bool=true, short=-s, long=--site-config, description=specify the site config file (default: site.json)], , _allowUnknownOption=false, _args=[], _name=deploy, _noHelp=false, commands=[commands=[], options=[flags=-c, --convert, required=0, optional=0, bool=true, short=-c, long=--convert, description=convert a GitHub wiki or docs folder to a MarkBind website, flags=-t, --template <type>, required=-16, optional=0, bool=true, short=-t, long=--template, description=initialise markbind with a specified template], , _allowUnknownOption=false, _args=[required=false, name=root, variadic=false], _name=init, _noHelp=false, $ref=$["parent"], option:convert=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:template=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, _eventsCount=2, template=default, _alias=i, _description=init a markbind website project, commands=[], options=[flags=-f, --force-reload, required=0, optional=0, bool=true, short=-f, long=--force-reload, description=force a full reload of all site files when a file is changed, flags=-n, --no-open, required=0, optional=0, bool=false, short=-n, long=--no-open, description=do not automatically open the site in browser, flags=-o, --one-page <file>, required=-16, optional=0, bool=true, short=-o, long=--one-page, description=render and serve only a single page in the site, flags=-p, --port <port>, required=-12, optional=0, bool=true, short=-p, long=--port, description=port for server to listen on (Default is 8080), flags=-s, --site-config <file>, required=-19, optional=0, bool=true, short=-s, long=--site-config, description=specify the site config file (default: site.json)], , _allowUnknownOption=false, _args=[required=false, name=root, variadic=false], _name=serve, _noHelp=false, $ref=$["parent"], _alias=s, _description=build then serve a website from a directory, option:force-reload=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:open=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:one-page=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:port=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:site-config=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, _eventsCount=5, open=true, $ref=$, commands=[], options=[flags=--baseUrl [baseUrl], required=0, optional=-11, bool=true, long=--baseUrl, description=optional flag which overrides baseUrl in site.json, leave argument empty for empty baseUrl, flags=-s, --site-config <file>, required=-19, optional=0, bool=true, short=-s, long=--site-config, description=specify the site config file (default: site.json)], , _allowUnknownOption=false, _args=[required=false, name=root, variadic=false, required=false, name=output, variadic=false], _name=build, _noHelp=false, $ref=$["parent"], _alias=b, option:baseUrl=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:site-config=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, _eventsCount=2, _description=build a website], options=[flags=-V, --version, required=0, optional=0, bool=true, short=-V, long=--version, description=output the version number], , _allowUnknownOption=true, _args=[], _name=index, Command=function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = {};
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name || '';
}, Option=function Option(flags, description) {
  this.flags = flags;
  this.required = ~flags.indexOf('<');
  this.optional = ~flags.indexOf('[');
  this.bool = !~flags.indexOf('-no-');
  flags = flags.split(/[ ,|]+/);
  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || '';
}, _usage= <command>, _version=2.6.0, option:version=[function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, function() {
    process.stdout.write(str + '\n');
    process.exit(0);
  }], command:init=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:i=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:serve=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:s=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:deploy=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:d=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:build=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, command:b=function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && null == args[i]) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  }, _eventsCount=9, rawArgs=[C:\Program Files\nodejs\node.exe, C:\Users\neilb\AppData\Roaming\npm\node_modules\markbind-cli\index.js, deploy], args=[$ref=$], _alias=d, _description=deploy the site to the repo's Github pages., option:travis=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, option:site-config=function(val) {
    // coercion
    if (null !== val && fn) val = fn(val, undefined === self[name]
      ? defaultValue
      : self[name]);

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
      // if no value, bool true, and we have a default, then use it!
      if (null == val) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (null !== val) {
      // reassign
      self[name] = val;
    }
  }, _eventsCount=2
2019-12-06T08:41:17.925Z - info: Deployed!
2019-12-06T08:42:18.024Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:42:18.025Z - info: 
2019-12-06T08:42:25.269Z - info: Deployed!
2019-12-06T08:45:54.284Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:45:54.284Z - info: 
2019-12-06T08:46:01.266Z - info: Deployed!
2019-12-06T08:47:19.096Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:47:19.096Z - info: 
2019-12-06T08:47:24.461Z - error: fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.

2019-12-06T08:51:19.153Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:51:19.154Z - info: 
2019-12-06T08:51:26.371Z - info: Deployed!
2019-12-06T08:52:45.316Z - info: Website generation started at 4:52:45 PM
2019-12-06T08:52:45.435Z - info: Building assets...
2019-12-06T08:52:45.470Z - info: Assets built
2019-12-06T08:52:45.470Z - info: Generating pages...
2019-12-06T08:52:45.983Z - info: Pages built
2019-12-06T08:52:47.151Z - info: Website generation complete! Total build time: 1.895s
2019-12-06T08:52:47.152Z - info: Build success!
2019-12-06T08:52:47.154Z - info: Site data built
2019-12-06T08:52:54.178Z - info: Website generation started at 4:52:54 PM
2019-12-06T08:52:54.237Z - info: Building assets...
2019-12-06T08:52:54.274Z - info: Assets built
2019-12-06T08:52:54.274Z - info: Generating pages...
2019-12-06T08:52:54.711Z - info: Pages built
2019-12-06T08:52:54.843Z - info: Website generation complete! Total build time: 0.718s
2019-12-06T08:52:54.934Z - info: Serving "C:\Users\neilb\Projects\markbind-plain-site\_site" at http://127.0.0.1:8080
2019-12-06T08:52:54.934Z - info: Press CTRL+C to stop ...
2019-12-06T08:52:54.957Z - info: Site data built
2019-12-06T08:53:05.189Z - info: C:\Users\neilb\Projects\markbind-plain-site , C:\Users\neilb\Projects\markbind-plain-site\_site
2019-12-06T08:53:05.189Z - info: 
2019-12-06T08:53:18.116Z - info: Deployed!
